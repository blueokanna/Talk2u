// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'data_models.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `default_chat_model`, `default_thinking_model`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `CompressionImpactLevel`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

/// 应用设置
class AppSettings {
  final String? apiKey;
  final String defaultModel;
  final bool enableThinkingByDefault;
  final String chatModel;
  final String thinkingModel;

  const AppSettings({
    this.apiKey,
    required this.defaultModel,
    required this.enableThinkingByDefault,
    required this.chatModel,
    required this.thinkingModel,
  });

  static Future<AppSettings> default_() =>
      RustLib.instance.api.crateApiDataModelsAppSettingsDefault();

  @override
  int get hashCode =>
      apiKey.hashCode ^
      defaultModel.hashCode ^
      enableThinkingByDefault.hashCode ^
      chatModel.hashCode ^
      thinkingModel.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AppSettings &&
          runtimeType == other.runtimeType &&
          apiKey == other.apiKey &&
          defaultModel == other.defaultModel &&
          enableThinkingByDefault == other.enableThinkingByDefault &&
          chatModel == other.chatModel &&
          thinkingModel == other.thinkingModel;
}

@freezed
sealed class ChatStreamEvent with _$ChatStreamEvent {
  const ChatStreamEvent._();

  /// 正常内容增量
  const factory ChatStreamEvent.contentDelta(String field0) =
      ChatStreamEvent_ContentDelta;

  /// 思考内容增量
  const factory ChatStreamEvent.thinkingDelta(String field0) =
      ChatStreamEvent_ThinkingDelta;

  /// 流结束
  const factory ChatStreamEvent.done() = ChatStreamEvent_Done;

  /// 错误
  const factory ChatStreamEvent.error(String field0) = ChatStreamEvent_Error;
}

/// 对话
class Conversation {
  final String id;
  final String title;
  final List<Message> messages;
  final String model;
  final PlatformInt64 createdAt;
  final PlatformInt64 updatedAt;
  final DialogueStyle dialogueStyle;
  final int turnCount;
  final List<MemorySummary> memorySummaries;

  const Conversation({
    required this.id,
    required this.title,
    required this.messages,
    required this.model,
    required this.createdAt,
    required this.updatedAt,
    required this.dialogueStyle,
    required this.turnCount,
    required this.memorySummaries,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      title.hashCode ^
      messages.hashCode ^
      model.hashCode ^
      createdAt.hashCode ^
      updatedAt.hashCode ^
      dialogueStyle.hashCode ^
      turnCount.hashCode ^
      memorySummaries.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Conversation &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          title == other.title &&
          messages == other.messages &&
          model == other.model &&
          createdAt == other.createdAt &&
          updatedAt == other.updatedAt &&
          dialogueStyle == other.dialogueStyle &&
          turnCount == other.turnCount &&
          memorySummaries == other.memorySummaries;
}

/// 对话摘要（用于列表展示）
class ConversationSummary {
  final String id;
  final String title;
  final String lastMessagePreview;
  final String model;
  final PlatformInt64 updatedAt;

  const ConversationSummary({
    required this.id,
    required this.title,
    required this.lastMessagePreview,
    required this.model,
    required this.updatedAt,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      title.hashCode ^
      lastMessagePreview.hashCode ^
      model.hashCode ^
      updatedAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConversationSummary &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          title == other.title &&
          lastMessagePreview == other.lastMessagePreview &&
          model == other.model &&
          updatedAt == other.updatedAt;
}

/// 对话风格
enum DialogueStyle {
  /// 默认自由对话
  free,

  /// 纯对话模式（say only）
  sayOnly,

  /// 纯动作/旁白模式（do only）
  doOnly,

  /// 混合模式（say + do 自动识别）
  mixed;

  static Future<DialogueStyle> default_() =>
      RustLib.instance.api.crateApiDataModelsDialogueStyleDefault();
}

/// 记忆上下文增强卡片 — 为每条记忆附加结构化元信息
/// 参考智谱上下文增强技术：为知识切片"恢复记忆"
/// 包含来源信息、主题概括、关键实体、歧义消除
class MemoryContextCard {
  /// 来源：涵盖的轮次范围描述
  final String sourceRange;

  /// 主题标签（1-3个关键词）
  final List<String> topicTags;

  /// 关键实体（人物、地点、物品等）
  final List<String> keyEntities;

  /// 情感基调（正/负/中性 + 强度）
  final String emotionalTone;

  /// 因果关联：与其他记忆的关联描述
  final List<String> causalLinks;

  const MemoryContextCard({
    required this.sourceRange,
    required this.topicTags,
    required this.keyEntities,
    required this.emotionalTone,
    required this.causalLinks,
  });

  @override
  int get hashCode =>
      sourceRange.hashCode ^
      topicTags.hashCode ^
      keyEntities.hashCode ^
      emotionalTone.hashCode ^
      causalLinks.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MemoryContextCard &&
          runtimeType == other.runtimeType &&
          sourceRange == other.sourceRange &&
          topicTags == other.topicTags &&
          keyEntities == other.keyEntities &&
          emotionalTone == other.emotionalTone &&
          causalLinks == other.causalLinks;
}

/// 记忆检索结果
class MemorySearchResult {
  final String summary;
  final List<String> coreFacts;
  final double relevanceScore;

  const MemorySearchResult({
    required this.summary,
    required this.coreFacts,
    required this.relevanceScore,
  });

  @override
  int get hashCode =>
      summary.hashCode ^ coreFacts.hashCode ^ relevanceScore.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MemorySearchResult &&
          runtimeType == other.runtimeType &&
          summary == other.summary &&
          coreFacts == other.coreFacts &&
          relevanceScore == other.relevanceScore;
}

/// 记忆摘要条目
class MemorySummary {
  final String id;
  final String summary;

  /// 核心身份/事件等不可变信息
  final List<String> coreFacts;

  /// 涵盖的消息范围 [start_turn, end_turn]
  final int turnRangeStart;
  final int turnRangeEnd;
  final PlatformInt64 createdAt;

  /// BM25 关键词索引
  final List<String> keywords;

  /// 压缩代数：每次被合并/压缩时 +1，代数越高信息损耗风险越大
  final int compressionGeneration;

  /// 上下文增强卡片 — 结构化元信息，提升检索精度
  final MemoryContextCard? contextCard;

  /// 每条核心事实的排级分类，与 core_facts 一一对应
  final List<MemoryTier> factTiers;

  const MemorySummary({
    required this.id,
    required this.summary,
    required this.coreFacts,
    required this.turnRangeStart,
    required this.turnRangeEnd,
    required this.createdAt,
    required this.keywords,
    required this.compressionGeneration,
    this.contextCard,
    required this.factTiers,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      summary.hashCode ^
      coreFacts.hashCode ^
      turnRangeStart.hashCode ^
      turnRangeEnd.hashCode ^
      createdAt.hashCode ^
      keywords.hashCode ^
      compressionGeneration.hashCode ^
      contextCard.hashCode ^
      factTiers.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MemorySummary &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          summary == other.summary &&
          coreFacts == other.coreFacts &&
          turnRangeStart == other.turnRangeStart &&
          turnRangeEnd == other.turnRangeEnd &&
          createdAt == other.createdAt &&
          keywords == other.keywords &&
          compressionGeneration == other.compressionGeneration &&
          contextCard == other.contextCard &&
          factTiers == other.factTiers;
}

/// 分级压缩排级 — 类似军队排级的信息优先级
/// 当记忆条目过多需要二次压缩时，按排级决定保留优先级
enum MemoryTier {
  /// 最高级：身份锚点（姓名、核心设定、与用户关系）— 永不丢弃
  identity,

  /// 高级：不可逆事件（关键转折、承诺、约定）— 极少丢弃
  criticalEvent,

  /// 中级：关系动态（亲密度变化、信任变化）— 可合并但不丢弃
  relationshipDynamic,

  /// 普通：状态信息（当前情绪、物理状态）— 可被最新状态覆盖
  currentState,

  /// 低级：场景细节（氛围、环境描写）— 可安全丢弃
  sceneDetail,
}

/// 单条消息
class Message {
  final String id;
  final MessageRole role;
  final String content;
  final String? thinkingContent;
  final String model;
  final PlatformInt64 timestamp;
  final MessageType messageType;

  const Message({
    required this.id,
    required this.role,
    required this.content,
    this.thinkingContent,
    required this.model,
    required this.timestamp,
    required this.messageType,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      role.hashCode ^
      content.hashCode ^
      thinkingContent.hashCode ^
      model.hashCode ^
      timestamp.hashCode ^
      messageType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Message &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          role == other.role &&
          content == other.content &&
          thinkingContent == other.thinkingContent &&
          model == other.model &&
          timestamp == other.timestamp &&
          messageType == other.messageType;
}

/// 消息角色
enum MessageRole { user, assistant, system }

/// 消息类型标记：say（对话）或 do（动作/旁白）
enum MessageType {
  say,
  do_,
  mixed;

  static Future<MessageType> default_() =>
      RustLib.instance.api.crateApiDataModelsMessageTypeDefault();
}

/// 模型信息
class ModelInfo {
  final String id;
  final String name;

  /// 最大输入上下文 token 数
  final BigInt contextTokens;

  /// 最大输出 token 数
  final BigInt maxOutputTokens;
  final bool supportsThinking;

  const ModelInfo({
    required this.id,
    required this.name,
    required this.contextTokens,
    required this.maxOutputTokens,
    required this.supportsThinking,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      name.hashCode ^
      contextTokens.hashCode ^
      maxOutputTokens.hashCode ^
      supportsThinking.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ModelInfo &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          contextTokens == other.contextTokens &&
          maxOutputTokens == other.maxOutputTokens &&
          supportsThinking == other.supportsThinking;
}
