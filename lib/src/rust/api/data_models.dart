// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'data_models.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `default_chat_model`, `default_thinking_model`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `eq`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`

/// 应用设置
class AppSettings {
  final String? apiKey;
  final String defaultModel;
  final bool enableThinkingByDefault;
  final String chatModel;
  final String thinkingModel;

  const AppSettings({
    this.apiKey,
    required this.defaultModel,
    required this.enableThinkingByDefault,
    required this.chatModel,
    required this.thinkingModel,
  });

  static Future<AppSettings> default_() =>
      RustLib.instance.api.crateApiDataModelsAppSettingsDefault();

  @override
  int get hashCode =>
      apiKey.hashCode ^
      defaultModel.hashCode ^
      enableThinkingByDefault.hashCode ^
      chatModel.hashCode ^
      thinkingModel.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AppSettings &&
          runtimeType == other.runtimeType &&
          apiKey == other.apiKey &&
          defaultModel == other.defaultModel &&
          enableThinkingByDefault == other.enableThinkingByDefault &&
          chatModel == other.chatModel &&
          thinkingModel == other.thinkingModel;
}

@freezed
sealed class ChatStreamEvent with _$ChatStreamEvent {
  const ChatStreamEvent._();

  /// 正常内容增量
  const factory ChatStreamEvent.contentDelta(String field0) =
      ChatStreamEvent_ContentDelta;

  /// 思考内容增量
  const factory ChatStreamEvent.thinkingDelta(String field0) =
      ChatStreamEvent_ThinkingDelta;

  /// 流结束
  const factory ChatStreamEvent.done() = ChatStreamEvent_Done;

  /// 错误
  const factory ChatStreamEvent.error(String field0) = ChatStreamEvent_Error;
}

/// 对话
class Conversation {
  final String id;
  final String title;
  final List<Message> messages;
  final String model;
  final PlatformInt64 createdAt;
  final PlatformInt64 updatedAt;
  final DialogueStyle dialogueStyle;
  final int turnCount;
  final List<MemorySummary> memorySummaries;

  const Conversation({
    required this.id,
    required this.title,
    required this.messages,
    required this.model,
    required this.createdAt,
    required this.updatedAt,
    required this.dialogueStyle,
    required this.turnCount,
    required this.memorySummaries,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      title.hashCode ^
      messages.hashCode ^
      model.hashCode ^
      createdAt.hashCode ^
      updatedAt.hashCode ^
      dialogueStyle.hashCode ^
      turnCount.hashCode ^
      memorySummaries.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Conversation &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          title == other.title &&
          messages == other.messages &&
          model == other.model &&
          createdAt == other.createdAt &&
          updatedAt == other.updatedAt &&
          dialogueStyle == other.dialogueStyle &&
          turnCount == other.turnCount &&
          memorySummaries == other.memorySummaries;
}

/// 对话摘要（用于列表展示）
class ConversationSummary {
  final String id;
  final String title;
  final String lastMessagePreview;
  final String model;
  final PlatformInt64 updatedAt;

  const ConversationSummary({
    required this.id,
    required this.title,
    required this.lastMessagePreview,
    required this.model,
    required this.updatedAt,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      title.hashCode ^
      lastMessagePreview.hashCode ^
      model.hashCode ^
      updatedAt.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ConversationSummary &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          title == other.title &&
          lastMessagePreview == other.lastMessagePreview &&
          model == other.model &&
          updatedAt == other.updatedAt;
}

/// 对话风格
enum DialogueStyle {
  /// 默认自由对话
  free,

  /// 纯对话模式（say only）
  sayOnly,

  /// 纯动作/旁白模式（do only）
  doOnly,

  /// 混合模式（say + do 自动识别）
  mixed;

  static Future<DialogueStyle> default_() =>
      RustLib.instance.api.crateApiDataModelsDialogueStyleDefault();
}

/// 记忆检索结果
class MemorySearchResult {
  final String summary;
  final List<String> coreFacts;
  final double relevanceScore;

  const MemorySearchResult({
    required this.summary,
    required this.coreFacts,
    required this.relevanceScore,
  });

  @override
  int get hashCode =>
      summary.hashCode ^ coreFacts.hashCode ^ relevanceScore.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MemorySearchResult &&
          runtimeType == other.runtimeType &&
          summary == other.summary &&
          coreFacts == other.coreFacts &&
          relevanceScore == other.relevanceScore;
}

/// 记忆摘要条目
class MemorySummary {
  final String id;
  final String summary;

  /// 核心身份/事件等不可变信息
  final List<String> coreFacts;

  /// 涵盖的消息范围 [start_turn, end_turn]
  final int turnRangeStart;
  final int turnRangeEnd;
  final PlatformInt64 createdAt;

  /// BM25 关键词索引
  final List<String> keywords;

  const MemorySummary({
    required this.id,
    required this.summary,
    required this.coreFacts,
    required this.turnRangeStart,
    required this.turnRangeEnd,
    required this.createdAt,
    required this.keywords,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      summary.hashCode ^
      coreFacts.hashCode ^
      turnRangeStart.hashCode ^
      turnRangeEnd.hashCode ^
      createdAt.hashCode ^
      keywords.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is MemorySummary &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          summary == other.summary &&
          coreFacts == other.coreFacts &&
          turnRangeStart == other.turnRangeStart &&
          turnRangeEnd == other.turnRangeEnd &&
          createdAt == other.createdAt &&
          keywords == other.keywords;
}

/// 单条消息
class Message {
  final String id;
  final MessageRole role;
  final String content;
  final String? thinkingContent;
  final String model;
  final PlatformInt64 timestamp;
  final MessageType messageType;

  const Message({
    required this.id,
    required this.role,
    required this.content,
    this.thinkingContent,
    required this.model,
    required this.timestamp,
    required this.messageType,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      role.hashCode ^
      content.hashCode ^
      thinkingContent.hashCode ^
      model.hashCode ^
      timestamp.hashCode ^
      messageType.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Message &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          role == other.role &&
          content == other.content &&
          thinkingContent == other.thinkingContent &&
          model == other.model &&
          timestamp == other.timestamp &&
          messageType == other.messageType;
}

/// 消息角色
enum MessageRole { user, assistant, system }

/// 消息类型标记：say（对话）或 do（动作/旁白）
enum MessageType {
  say,
  do_,
  mixed;

  static Future<MessageType> default_() =>
      RustLib.instance.api.crateApiDataModelsMessageTypeDefault();
}

/// 模型信息
class ModelInfo {
  final String id;
  final String name;
  final BigInt contextTokens;
  final bool supportsThinking;

  const ModelInfo({
    required this.id,
    required this.name,
    required this.contextTokens,
    required this.supportsThinking,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      name.hashCode ^
      contextTokens.hashCode ^
      supportsThinking.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ModelInfo &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          name == other.name &&
          contextTokens == other.contextTokens &&
          supportsThinking == other.supportsThinking;
}
