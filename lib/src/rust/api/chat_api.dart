// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'data_models.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `get_config_manager`, `get_conversation_store`, `get_data_path`

Future<void> initApp({required String dataPath}) =>
    RustLib.instance.api.crateApiChatApiInitApp(dataPath: dataPath);

Future<Conversation> createConversation() =>
    RustLib.instance.api.crateApiChatApiCreateConversation();

Future<List<ConversationSummary>> getConversationList() =>
    RustLib.instance.api.crateApiChatApiGetConversationList();

Future<Conversation?> getConversation({required String id}) =>
    RustLib.instance.api.crateApiChatApiGetConversation(id: id);

Future<bool> deleteConversation({required String id}) =>
    RustLib.instance.api.crateApiChatApiDeleteConversation(id: id);

/// Delete a single message from a conversation.
Future<bool> deleteMessage({
  required String conversationId,
  required String messageId,
}) => RustLib.instance.api.crateApiChatApiDeleteMessage(
  conversationId: conversationId,
  messageId: messageId,
);

/// Edit a message's content in a conversation.
Future<bool> editMessage({
  required String conversationId,
  required String messageId,
  required String newContent,
}) => RustLib.instance.api.crateApiChatApiEditMessage(
  conversationId: conversationId,
  messageId: messageId,
  newContent: newContent,
);

/// Rollback: delete the target user message and all messages after it.
/// Returns the list of deleted message IDs.
Future<List<String>> rollbackToMessage({
  required String conversationId,
  required String messageId,
}) => RustLib.instance.api.crateApiChatApiRollbackToMessage(
  conversationId: conversationId,
  messageId: messageId,
);

/// Add a system message to a conversation (used for character system prompts).
Future<bool> addSystemMessage({
  required String conversationId,
  required String content,
}) => RustLib.instance.api.crateApiChatApiAddSystemMessage(
  conversationId: conversationId,
  content: content,
);

/// Add an assistant message to a conversation (used for character greetings).
Future<bool> addAssistantMessage({
  required String conversationId,
  required String content,
}) => RustLib.instance.api.crateApiChatApiAddAssistantMessage(
  conversationId: conversationId,
  content: content,
);

/// 重启剧情：清除对话消息但保留角色设定和开场白
Future<bool> restartStory({required String conversationId}) => RustLib
    .instance
    .api
    .crateApiChatApiRestartStory(conversationId: conversationId);

/// 设置对话风格
Future<bool> setDialogueStyle({
  required String conversationId,
  required DialogueStyle style,
}) => RustLib.instance.api.crateApiChatApiSetDialogueStyle(
  conversationId: conversationId,
  style: style,
);

/// 检测消息的 say/do 类型
Future<MessageType> detectMessageType({required String content}) =>
    RustLib.instance.api.crateApiChatApiDetectMessageType(content: content);

/// 获取对话的轮次计数
Future<int> getTurnCount({required String conversationId}) => RustLib
    .instance
    .api
    .crateApiChatApiGetTurnCount(conversationId: conversationId);

/// 检查是否需要触发记忆总结
Future<bool> shouldSummarizeMemory({required String conversationId}) => RustLib
    .instance
    .api
    .crateApiChatApiShouldSummarizeMemory(conversationId: conversationId);

/// 搜索相关记忆
Future<List<MemorySearchResult>> searchMemories({
  required String conversationId,
  required String query,
  required BigInt topK,
}) => RustLib.instance.api.crateApiChatApiSearchMemories(
  conversationId: conversationId,
  query: query,
  topK: topK,
);

Future<AppSettings> getSettings() =>
    RustLib.instance.api.crateApiChatApiGetSettings();

Future<bool> saveSettings({required AppSettings settings}) =>
    RustLib.instance.api.crateApiChatApiSaveSettings(settings: settings);

Future<void> setApiKey({required String apiKey}) =>
    RustLib.instance.api.crateApiChatApiSetApiKey(apiKey: apiKey);

Future<bool> validateApiKey({required String apiKey}) =>
    RustLib.instance.api.crateApiChatApiValidateApiKey(apiKey: apiKey);

Future<List<ModelInfo>> getAvailableModels() =>
    RustLib.instance.api.crateApiChatApiGetAvailableModels();

/// Send a message and stream SSE events back to Flutter.
Stream<ChatStreamEvent> sendMessage({
  required String conversationId,
  required String content,
  required String model,
  required bool enableThinking,
}) => RustLib.instance.api.crateApiChatApiSendMessage(
  conversationId: conversationId,
  content: content,
  model: model,
  enableThinking: enableThinking,
);

/// Regenerate AI response without re-adding user message.
/// Used when user clicks "regenerate" on an AI message.
Stream<ChatStreamEvent> regenerateResponse({
  required String conversationId,
  required String model,
  required bool enableThinking,
}) => RustLib.instance.api.crateApiChatApiRegenerateResponse(
  conversationId: conversationId,
  model: model,
  enableThinking: enableThinking,
);

/// 触发记忆总结（在 send_message 完成后由 Flutter 端异步调用）
Stream<ChatStreamEvent> triggerMemorySummarize({
  required String conversationId,
}) => RustLib.instance.api.crateApiChatApiTriggerMemorySummarize(
  conversationId: conversationId,
);
