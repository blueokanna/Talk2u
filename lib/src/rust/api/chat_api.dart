// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'data_models.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `get_config_manager`, `get_conversation_store`, `get_data_path`, `resolve_chat_model`, `resolve_thinking_model`

Future<void> initApp({required String dataPath}) =>
    RustLib.instance.api.crateApiChatApiInitApp(dataPath: dataPath);

Future<Conversation> createConversation() =>
    RustLib.instance.api.crateApiChatApiCreateConversation();

Future<List<ConversationSummary>> getConversationList() =>
    RustLib.instance.api.crateApiChatApiGetConversationList();

Future<Conversation?> getConversation({required String id}) =>
    RustLib.instance.api.crateApiChatApiGetConversation(id: id);

Future<bool> deleteConversation({required String id}) =>
    RustLib.instance.api.crateApiChatApiDeleteConversation(id: id);

Future<bool> deleteMessage({
  required String conversationId,
  required String messageId,
}) => RustLib.instance.api.crateApiChatApiDeleteMessage(
  conversationId: conversationId,
  messageId: messageId,
);

Future<bool> editMessage({
  required String conversationId,
  required String messageId,
  required String newContent,
}) => RustLib.instance.api.crateApiChatApiEditMessage(
  conversationId: conversationId,
  messageId: messageId,
  newContent: newContent,
);

Future<List<String>> rollbackToMessage({
  required String conversationId,
  required String messageId,
}) => RustLib.instance.api.crateApiChatApiRollbackToMessage(
  conversationId: conversationId,
  messageId: messageId,
);

Future<bool> addSystemMessage({
  required String conversationId,
  required String content,
}) => RustLib.instance.api.crateApiChatApiAddSystemMessage(
  conversationId: conversationId,
  content: content,
);

Future<bool> addAssistantMessage({
  required String conversationId,
  required String content,
}) => RustLib.instance.api.crateApiChatApiAddAssistantMessage(
  conversationId: conversationId,
  content: content,
);

Future<bool> restartStory({required String conversationId}) => RustLib
    .instance
    .api
    .crateApiChatApiRestartStory(conversationId: conversationId);

Future<bool> setDialogueStyle({
  required String conversationId,
  required DialogueStyle style,
}) => RustLib.instance.api.crateApiChatApiSetDialogueStyle(
  conversationId: conversationId,
  style: style,
);

Future<MessageType> detectMessageType({required String content}) =>
    RustLib.instance.api.crateApiChatApiDetectMessageType(content: content);

Future<int> getTurnCount({required String conversationId}) => RustLib
    .instance
    .api
    .crateApiChatApiGetTurnCount(conversationId: conversationId);

Future<bool> shouldSummarizeMemory({required String conversationId}) => RustLib
    .instance
    .api
    .crateApiChatApiShouldSummarizeMemory(conversationId: conversationId);

Future<List<MemorySearchResult>> searchMemories({
  required String conversationId,
  required String query,
  required BigInt topK,
}) => RustLib.instance.api.crateApiChatApiSearchMemories(
  conversationId: conversationId,
  query: query,
  topK: topK,
);

Future<AppSettings> getSettings() =>
    RustLib.instance.api.crateApiChatApiGetSettings();

Future<bool> saveSettings({required AppSettings settings}) =>
    RustLib.instance.api.crateApiChatApiSaveSettings(settings: settings);

Future<void> setApiKey({required String apiKey}) =>
    RustLib.instance.api.crateApiChatApiSetApiKey(apiKey: apiKey);

Future<bool> validateApiKey({required String apiKey}) =>
    RustLib.instance.api.crateApiChatApiValidateApiKey(apiKey: apiKey);

Future<List<ModelInfo>> getAvailableModels() =>
    RustLib.instance.api.crateApiChatApiGetAvailableModels();

Stream<ChatStreamEvent> sendMessage({
  required String conversationId,
  required String content,
  required String model,
  required bool enableThinking,
}) => RustLib.instance.api.crateApiChatApiSendMessage(
  conversationId: conversationId,
  content: content,
  model: model,
  enableThinking: enableThinking,
);

Stream<ChatStreamEvent> regenerateResponse({
  required String conversationId,
  required String model,
  required bool enableThinking,
}) => RustLib.instance.api.crateApiChatApiRegenerateResponse(
  conversationId: conversationId,
  model: model,
  enableThinking: enableThinking,
);

Stream<ChatStreamEvent> triggerMemorySummarize({
  required String conversationId,
}) => RustLib.instance.api.crateApiChatApiTriggerMemorySummarize(
  conversationId: conversationId,
);
